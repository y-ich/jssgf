###
SGF libarary
(C) 2013-2014 ICHIKAWA, Yuji (New 3 Rs)
###
###
# jssgf.parse to parse SGF string
# jssgf.isSgf to check if a string is SGF
# jssgf.nthMoveNode to get a node of nth move
###

parser.stringify = (c) ->
    ###
    stringifies collection c
    parser is a export variable generated by jison
    ###
    c.map(gameTree2string).join ''

gameTree2string = (gameTree) ->
    result = '('
    n = gameTree
    loop
        result += node2string n
        if n._children.length == 0
            break
        else if n._children.length == 1
            n = n._children[0]
        else
            result += (gameTree2string e for e in n._children).join ''
            break
    result += ')'

PRIOR = ['FF', 'GM', 'CA']
EXCEPT = new RegExp "^(_|#{PRIOR.join '|'})"
node2string = (node) ->
    result = ';'
    for property in PRIOR when node[property]?
        result += property + propvalues2string node[property]
    result + (k + propvalues2string v for k, v of node when not EXCEPT.test k).join ''

propvalues2string = (propvalues) ->
    propvalues = [propvalues] unless propvalues instanceof Array
    ("[#{escapePropvalue e}]" for e in propvalues).join ''

escapePropvalue = (propvalue) ->
    # propvalue.replace /([\]\\:])/g, '\\$1'
    propvalue.replace /([\]\\])/g, '\\$1' # do not escape : because it is not interpreted yet.

parser.isSgf = (sgf) ->
    ### returns true if string sgf is SGF format. ###
    try
        parser.fastParse sgf
        true
    catch e
        false

parser.opponentOf = (color) ->
    switch color
        when 'B'
            return 'W'
        when 'W'
            return 'B'
        else
            throw new Error 'illegal argument'

parser.nthMoveNode = (root, n) ->
    ###
    returns a node of primary nth move
    if n is larger than total moves, returns the last move
    ###
    num = 0
    node = root
    while node._children.length > 0 and num < n
        node = node._children[0]
        if node.B? or node.W?
            num += 1
    node

parseValue = (str) ->
    VALUE = /\[((?:\\]|[^\]])*)\]\s*/g

    while value = VALUE.exec str
        value = decodeValue value[1]
        switch typeof result
            when 'undefined'
                result = value
            when 'string'
                result = [result, value]
            else
                result.push value
    result

parseNode = (str) ->
    PROPERTY = ///
        ([A-Z]+)\s*                   # propIdent
        ((:?\[(?:(?:\\]|[^\]])*)\]\s*)+) # propValue
        ///g
    result = {}
    while match = PROPERTY.exec str
        result[match[1]] = parseValue match[2]
    result

parseSequence = (str) ->
    NODE = ///
        (;\s*                               # node
            (?:[A-Z]+\s*                    # propIdent
                (?:\[(?:(?:\\]|[^\]])*)\]\s*)+ # propValue
            )*
        )
        ///g
    preroot = {}
    node = preroot
    while match = NODE.exec str
        n = parseNode match[1]
        node._children = [n]
        node = n
    node._children = []
    preroot._children

parser.fastParse = (sgf) ->
    singleSequence = sgf.match ///
        ^\s*\(\s*
        (
            (?:;\s*                             # node
                (?:[A-Z]+\s*                    # propIdent
                    (?:\[(?:(?:\\]|[^\]])*)\]\s*)+ # propValue
                )*
            )+
        )
        \)\s*$
        ///
    if singleSequence?
        parseSequence singleSequence[1]
    else
        parser.parse sgf
